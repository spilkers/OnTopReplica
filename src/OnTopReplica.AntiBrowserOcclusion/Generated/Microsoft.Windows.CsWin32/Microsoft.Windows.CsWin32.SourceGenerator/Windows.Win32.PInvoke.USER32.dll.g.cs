// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

#pragma warning disable CS1591,CS1573,CS0465,CS0649,CS8019,CS1570,CS1584,CS1658,CS0436,CS8981
using global::System;
using global::System.Diagnostics;
using global::System.Diagnostics.CodeAnalysis;
using global::System.Runtime.CompilerServices;
using global::System.Runtime.InteropServices;
using winmdroot = global::Windows.Win32;
namespace Windows.Win32
{

	/// <content>
	/// Contains extern methods from "USER32.dll".
	/// </content>
	internal static partial class PInvoke
	{
		/// <summary>Destroys the specified menu and frees any memory that the menu occupies.</summary>
		/// <param name="hMenu">
		/// <para>Type: <b>HMENU</b> A handle to the menu to be destroyed.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroymenu#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
		/// </returns>
		/// <remarks>
		/// <para>Before closing, an application must use the <b>DestroyMenu</b> function to destroy a menu not assigned to a window. A menu that is assigned to a window is automatically destroyed when the application closes. <b>DestroyMenu</b> is recursive, that is, it will destroy the menu and all its submenus.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroymenu#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("USER32.dll", ExactSpelling = true, SetLastError = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern winmdroot.Foundation.BOOL DestroyMenu(winmdroot.UI.WindowsAndMessaging.HMENU hMenu);

		/// <inheritdoc cref="CreateWindowEx(winmdroot.UI.WindowsAndMessaging.WINDOW_EX_STYLE, winmdroot.Foundation.PCWSTR, winmdroot.Foundation.PCWSTR, winmdroot.UI.WindowsAndMessaging.WINDOW_STYLE, int, int, int, int, winmdroot.Foundation.HWND, winmdroot.UI.WindowsAndMessaging.HMENU, winmdroot.Foundation.HINSTANCE, void*)"/>
		internal static unsafe winmdroot.Foundation.HWND CreateWindowEx(winmdroot.UI.WindowsAndMessaging.WINDOW_EX_STYLE dwExStyle, string lpClassName, string lpWindowName, winmdroot.UI.WindowsAndMessaging.WINDOW_STYLE dwStyle, int X, int Y, int nWidth, int nHeight, winmdroot.Foundation.HWND hWndParent, SafeHandle hMenu, SafeHandle hInstance, void* lpParam)
		{
			bool hMenuAddRef = false;
			bool hInstanceAddRef = false;
			try
			{
				fixed (char* lpWindowNameLocal = lpWindowName)
				{
					fixed (char* lpClassNameLocal = lpClassName)
					{
						winmdroot.UI.WindowsAndMessaging.HMENU hMenuLocal;
						if (hMenu is object)
						{
							hMenu.DangerousAddRef(ref hMenuAddRef);
							hMenuLocal = (winmdroot.UI.WindowsAndMessaging.HMENU)hMenu.DangerousGetHandle();
						}
						else
							hMenuLocal = (winmdroot.UI.WindowsAndMessaging.HMENU )new IntPtr(0L);
						winmdroot.Foundation.HINSTANCE hInstanceLocal;
						if (hInstance is object)
						{
							hInstance.DangerousAddRef(ref hInstanceAddRef);
							hInstanceLocal = (winmdroot.Foundation.HINSTANCE)hInstance.DangerousGetHandle();
						}
						else
							hInstanceLocal = (winmdroot.Foundation.HINSTANCE )new IntPtr(0L);
						winmdroot.Foundation.HWND __result = PInvoke.CreateWindowEx(dwExStyle, lpClassNameLocal, lpWindowNameLocal, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenuLocal, hInstanceLocal, lpParam);
						return __result;
					}
				}
			}
			finally
			{
				if (hMenuAddRef)
					hMenu.DangerousRelease();
				if (hInstanceAddRef)
					hInstance.DangerousRelease();
			}
		}

		/// <summary>Creates an overlapped, pop-up, or child window with an extended window style; otherwise, this function is identical to the CreateWindow function. (Unicode)</summary>
		/// <param name="dwExStyle">
		/// <para>Type: <b>DWORD</b> The extended window style of the window being created. For a list of possible values, see  <a href="https://docs.microsoft.com/windows/desktop/winmsg/extended-window-styles">Extended Window Styles</a>.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="lpClassName">
		/// <para>Type: <b>LPCTSTR</b> A <b>null</b>-terminated string or a class atom created by a previous call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. The atom must be in the low-order word of <i>lpClassName</i>; the high-order word must be zero. If <i>lpClassName</i> is a string, it specifies the window class name. The class name can be any name registered with <b>RegisterClass</b> or <b>RegisterClassEx</b>, provided that the module that registers the class is also the module that creates the window. The class name can also be any of the predefined <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-window-classes">system class</a> names.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="lpWindowName">
		/// <para>Type: <b>LPCTSTR</b> The window name. If the window style specifies a title bar, the window title pointed to by <i>lpWindowName</i> is displayed in the title bar. When using <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a> to create controls, such as buttons, check boxes, and static controls, use <i>lpWindowName</i> to specify the text of the control. When creating a static control with the <b>SS_ICON</b> style, use <i>lpWindowName</i> to specify the icon name or identifier. To specify an identifier, use the syntax "#<i>num</i>".</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="dwStyle">
		/// <para>Type: <b>DWORD</b> The style of the window being created. This parameter can be a combination of the <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-styles">window style values</a>, plus the control styles indicated in the Remarks section.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="X">
		/// <para>Type: <b>int</b> The initial horizontal position of the window. For an overlapped or pop-up window, the <i>x</i> parameter is the initial x-coordinate of the window's upper-left corner, in screen coordinates. For a child window, <i>x</i> is the x-coordinate of the upper-left corner of the window relative to the upper-left corner of the parent window's client area. If <i>x</i> is set to <b>CW_USEDEFAULT</b>, the system selects the default position for the window's upper-left corner and ignores the <i>y</i> parameter. <b>CW_USEDEFAULT</b> is valid only for overlapped windows; if it is specified for a pop-up or child window, the <i>x</i> and <i>y</i> parameters are set to zero.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="Y">
		/// <para>Type: <b>int</b> The initial vertical position of the window. For an overlapped or pop-up window, the <i>y</i> parameter is the initial y-coordinate of the window's upper-left corner, in screen coordinates. For a child window, <i>y</i> is the initial y-coordinate of the upper-left corner of the child window relative to the upper-left corner of the parent window's client area. For a list box <i>y</i> is the initial y-coordinate of the upper-left corner of the list box's client area relative to the upper-left corner of the parent window's client area.</para>
		/// <para>If an overlapped window is created with the <b>WS_VISIBLE</b> style bit set and the <i>x</i> parameter is set to <b>CW_USEDEFAULT</b>, then the <i>y</i> parameter determines how the window is shown. If the <i>y</i> parameter is <b>CW_USEDEFAULT</b>, then the window manager calls <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a> with the <b>SW_SHOW</b> flag after the window has been created. If the <i>y</i> parameter is some other value, then the window manager calls <b>ShowWindow</b> with that value as the <i>nCmdShow</i> parameter.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="nWidth">
		/// <para>Type: <b>int</b> The width, in device units, of the window. For overlapped windows, <i>nWidth</i> is the window's width, in screen coordinates, or <b>CW_USEDEFAULT</b>. If <i>nWidth</i> is <b>CW_USEDEFAULT</b>, the system selects a default width and height for the window; the default width extends from the initial x-coordinates to the right edge of the screen; the default height extends from the initial y-coordinate to the top of the icon area. <b>CW_USEDEFAULT</b> is valid only for overlapped windows; if <b>CW_USEDEFAULT</b> is specified for a pop-up or child window, the <i>nWidth</i> and <i>nHeight</i> parameter are set to zero.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="nHeight">
		/// <para>Type: <b>int</b> The height, in device units, of the window. For overlapped windows, <i>nHeight</i> is the window's height, in screen coordinates. If the <i>nWidth</i> parameter is set to <b>CW_USEDEFAULT</b>, the system ignores <i>nHeight</i>.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="hWndParent">
		/// <para>Type: <b>HWND</b> A handle to the parent or owner window of the window being created. To create a child window or an owned window, supply a valid window handle. This parameter is optional for pop-up windows. To create a <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-features">message-only window</a>, supply <b>HWND_MESSAGE</b> or a handle to an existing message-only window.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="hMenu">
		/// <para>Type: <b>HMENU</b> A handle to a menu, or specifies a child-window identifier, depending on the window style. For an overlapped or pop-up window, <i>hMenu</i> identifies the menu to be used with the window; it can be <b>NULL</b> if the class menu is to be used. For a child window, <i>hMenu</i> specifies the child-window identifier, an integer value used by a dialog box control to notify its parent about events. The application determines the child-window identifier; it must be unique for all child windows with the same parent window.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="hInstance">
		/// <para>Type: <b>HINSTANCE</b> A handle to the instance of the module to be associated with the window.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="lpParam">
		/// <para>Type: <b>LPVOID</b> Pointer to a value to be passed to the window through the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-createstructa">CREATESTRUCT</a> structure (<b>lpCreateParams</b> member) pointed to by the <i>lParam</i> param of the <b>WM_CREATE</b> message.  This message is sent to the created window by this function before it returns. If an application calls <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a> to create a MDI client window, <i>lpParam</i> should point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-clientcreatestruct">CLIENTCREATESTRUCT</a> structure. If an MDI client window calls <b>CreateWindow</b> to create an MDI child window, <i>lpParam</i> should point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-mdicreatestructa">MDICREATESTRUCT</a> structure. <i>lpParam</i> may be <b>NULL</b> if no additional data is needed.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b>HWND</b> If the function succeeds, the return value is a handle to the new window. If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. This function typically fails for one of the following reasons: </para>
		/// <para>This doc was truncated.</para>
		/// </returns>
		/// <remarks>
		/// <para>The <b>CreateWindowEx</b> function sends <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-nccreate">WM_NCCREATE</a>, <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-nccalcsize">WM_NCCALCSIZE</a>, and <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-create">WM_CREATE</a> messages to the window being created. If the created window is a child window, its default position is at the bottom of the Z-order. If the created window is a top-level window, its default position is at the top of the Z-order (but beneath all topmost windows unless the created window is itself topmost). For information on controlling whether the Taskbar displays a button for the created window, see <a href="https://docs.microsoft.com/windows/desktop/shell/taskbar">Managing Taskbar Buttons</a>. For information on removing a window, see the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroywindow">DestroyWindow</a> function. The following predefined control classes can be specified in the <i>lpClassName</i> parameter. Note the corresponding control styles you can use in the <i>dwStyle</i> parameter. </para>
		/// <para>This doc was truncated.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("USER32.dll", ExactSpelling = true, EntryPoint = "CreateWindowExW", SetLastError = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe winmdroot.Foundation.HWND CreateWindowEx(winmdroot.UI.WindowsAndMessaging.WINDOW_EX_STYLE dwExStyle, winmdroot.Foundation.PCWSTR lpClassName, winmdroot.Foundation.PCWSTR lpWindowName, winmdroot.UI.WindowsAndMessaging.WINDOW_STYLE dwStyle, int X, int Y, int nWidth, int nHeight, winmdroot.Foundation.HWND hWndParent, winmdroot.UI.WindowsAndMessaging.HMENU hMenu, winmdroot.Foundation.HINSTANCE hInstance, [Optional] void* lpParam);

		/// <summary>Destroys an icon and frees any memory the icon occupied.</summary>
		/// <param name="hIcon">
		/// <para>Type: <b>HICON</b> A handle to the icon to be destroyed. The icon must not be in use.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroyicon#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
		/// </returns>
		/// <remarks>
		/// <para>It is only necessary to call <b>DestroyIcon</b> for icons and cursors created with the following functions: <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createiconfromresourceex">CreateIconFromResourceEx</a> (if called without the <b>LR_SHARED</b> flag), <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createiconindirect">CreateIconIndirect</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-copyicon">CopyIcon</a>. Do not use this function to destroy a shared icon. A shared icon is valid as long as the module from which it was loaded remains in memory. The following functions obtain a shared icon. </para>
		/// <para>This doc was truncated.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroyicon#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("USER32.dll", ExactSpelling = true, SetLastError = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern winmdroot.Foundation.BOOL DestroyIcon(winmdroot.UI.WindowsAndMessaging.HICON hIcon);

		/// <summary>Destroys a cursor and frees any memory the cursor occupied. Do not use this function to destroy a shared cursor.</summary>
		/// <param name="hCursor">
		/// <para>Type: <b>HCURSOR</b> A handle to the cursor to be destroyed. The cursor must not be in use.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroycursor#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
		/// </returns>
		/// <remarks>
		/// <para>The <b>DestroyCursor</b> function destroys a nonshared cursor. Do not use this function to destroy a shared cursor. A shared cursor is valid as long as the module from which it was loaded remains in memory. The following functions obtain a shared cursor: </para>
		/// <para>This doc was truncated.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroycursor#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("USER32.dll", ExactSpelling = true, SetLastError = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern winmdroot.Foundation.BOOL DestroyCursor(winmdroot.UI.WindowsAndMessaging.HCURSOR hCursor);

		/// <summary>Registers a window class for subsequent use in calls to the CreateWindow or CreateWindowEx function. (RegisterClassW)</summary>
		/// <param name="lpWndClass">
		/// <para>Type: <b>const WNDCLASS*</b> A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassa">WNDCLASS</a> structure. You must fill the structure with the appropriate class attributes before passing it to the function.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-registerclassw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b>ATOM</b> If the function succeeds, the return value is a class atom that uniquely identifies the class being registered. This atom can only be used by the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getclassinfoa">GetClassInfo</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getclassinfoexa">GetClassInfoEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-findwindowa">FindWindow</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-findwindowexa">FindWindowEx</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-unregisterclassa">UnregisterClass</a> functions and the <b>IActiveIMMap::FilterClientWindows</b> method. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
		/// </returns>
		/// <remarks>
		/// <para>If you register the window class by using <b>RegisterClassA</b>, the application tells the system that the windows of the created class expect messages with text or character parameters to use the ANSI character set; if you register it by using <b>RegisterClassW</b>, the application requests that the system pass text parameters of messages as Unicode. The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-iswindowunicode">IsWindowUnicode</a> function enables applications to query the nature of each window. For more information on ANSI and Unicode functions, see <a href="https://docs.microsoft.com/windows/desktop/Intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>. All window classes that an application registers are unregistered when it terminates. No window classes registered by a DLL are unregistered when the DLL is unloaded. A DLL must explicitly unregister its classes when it is unloaded.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-registerclassw#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("USER32.dll", ExactSpelling = true, EntryPoint = "RegisterClassW", SetLastError = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern ushort RegisterClass(in winmdroot.UI.WindowsAndMessaging.WNDCLASSW lpWndClass);

		/// <summary>Calls the default window procedure to provide default processing for any window messages that an application does not process. (Unicode)</summary>
		/// <param name="hWnd">
		/// <para>Type: <b>HWND</b> A handle to the window procedure that received the message.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="Msg">
		/// <para>Type: <b>UINT</b> The message.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="wParam">
		/// <para>Type: <b>WPARAM</b> Additional message information. The content of this parameter depends on the value of the <i>Msg</i> parameter.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="lParam">
		/// <para>Type: <b>LPARAM</b> Additional message information. The content of this parameter depends on the value of the <i>Msg</i> parameter.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b>LRESULT</b> The return value is the result of the message processing and depends on the message.</para>
		/// </returns>
		/// <remarks>
		/// <para>> [!NOTE] > The winuser.h header defines DefWindowProc as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defwindowprocw#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("USER32.dll", ExactSpelling = true, EntryPoint = "DefWindowProcW")]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern winmdroot.Foundation.LRESULT DefWindowProc(winmdroot.Foundation.HWND hWnd, uint Msg, winmdroot.Foundation.WPARAM wParam, winmdroot.Foundation.LPARAM lParam);

		/// <summary>Signals the system that a predefined event occurred. If any client applications have registered a hook function for the event, the system calls the client's hook function.</summary>
		/// <param name="hwnd">
		/// <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HWND</a></b> Handle to the window that contains the object that generated the event.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-notifywinevent#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="idObject">
		/// <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">LONG</a></b> Identifies the object that generated the event. This value is either one of the predefined <a href="https://docs.microsoft.com/windows/desktop/WinAuto/object-identifiers">object identifiers</a> or a custom object ID value.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-notifywinevent#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="idChild">
		/// <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">LONG</a></b> Identifies whether the event was generated by an object or by a child element of the object. If this value is CHILDID_SELF, the event was generated by the object itself. If not CHILDID_SELF, this value is the child ID of the element that generated the event.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-notifywinevent#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <remarks>
		/// <para>Servers call this function to notify the system that an event has occurred. Microsoft Active Accessibility checks to see if any client applications have set hook procedures for the event and, if so, calls the appropriate hook procedures. If no hook procedures are registered for the event, the performance penalty for calling this function is minor. Servers call <b>NotifyWinEvent</b> to announce the event to the system after the event has occurred; they must never notify the system of an event before the event has occurred. When the client's hook procedure is called, it receives a number of parameters that describe the event and the object that generated the event. The hook procedure uses the <a href="https://docs.microsoft.com/windows/desktop/api/oleacc/nf-oleacc-accessibleobjectfromevent">AccessibleObjectFromEvent</a> function to retrieve a pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/oleacc/nn-oleacc-iaccessible">IAccessible</a> interface of the object that generated the event. Servers may receive a [WM_GETOBJECT](/windows/win32/winauto/wm-getobject) message immediately after calling this function. This can happen if there are any in-context clients that call <a href="https://docs.microsoft.com/windows/desktop/api/oleacc/nf-oleacc-accessibleobjectfromevent">AccessibleObjectFromEvent</a> in the event callback. When servers call this function, they must be ready to handle [WM_GETOBJECT](/windows/win32/winauto/wm-getobject), return an <a href="https://docs.microsoft.com/windows/desktop/api/oleacc/nn-oleacc-iaccessible">IAccessible</a> interface pointer, and handle any of the <b>IAccessible</b> methods. <b>Note to Server Developers:  </b>When you call <b>NotifyWinEvent</b>, if any clients are listening for that event in-context, their event handlers, which typically send [WM_GETOBJECT](/windows/win32/winauto/wm-getobject) and call <a href="https://docs.microsoft.com/windows/desktop/api/oleacc/nn-oleacc-iaccessible">IAccessible</a> methods, will execute before <b>NotifyWinEvent</b> returns. When you call <b>NotifyWinEvent</b>, you should be prepared to handle these calls, if they occur. If you need to do extra setup to allow for this, you should do so before you call <b>NotifyWinEvent</b>, not after.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-notifywinevent#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("USER32.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern void NotifyWinEvent(uint @event, winmdroot.Foundation.HWND hwnd, int idObject, int idChild);

		/// <summary>Removes an event hook function created by a previous call to SetWinEventHook.</summary>
		/// <param name="hWinEventHook">
		/// <para>Type: <b>HWINEVENTHOOK</b> Handle to the event hook returned in the previous call to <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwineventhook">SetWinEventHook</a>.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-unhookwinevent#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">BOOL</a></b> If successful, returns <b>TRUE</b>; otherwise, returns <b>FALSE</b>. Three common errors cause this function to fail: </para>
		/// <para>This doc was truncated.</para>
		/// </returns>
		/// <remarks>
		/// <para>This function removes the event hook specified by <i>hWinEventHook</i> that prevents the corresponding callback function from receiving further event notifications. If the client's thread ends, the system automatically calls this function. Call this function from the same thread that installed the event hook. <b>UnhookWinEvent</b> fails if called from a thread different from the call that corresponds to <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwineventhook">SetWinEventHook</a>. If WINEVENT_INCONTEXT was specified when this event hook was installed, the system attempts to unload the corresponding DLL from all processes that loaded it. Although unloading does not occur immediately, the hook function is not called after <b>UnhookWinEvent</b> returns. For more information on WINEVENT_INCONTEXT, see <a href="https://docs.microsoft.com/windows/desktop/WinAuto/in-context-hook-functions">In-Context Hook Functions</a>.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-unhookwinevent#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("USER32.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern winmdroot.Foundation.BOOL UnhookWinEvent(winmdroot.UI.Accessibility.HWINEVENTHOOK hWinEventHook);

		/// <inheritdoc cref="SetWinEventHook(uint, uint, winmdroot.Foundation.HMODULE, winmdroot.UI.Accessibility.WINEVENTPROC, uint, uint, uint)"/>
		internal static unsafe UnhookWinEventSafeHandle SetWinEventHook(uint eventMin, uint eventMax, SafeHandle hmodWinEventProc, winmdroot.UI.Accessibility.WINEVENTPROC pfnWinEventProc, uint idProcess, uint idThread, uint dwFlags)
		{
			bool hmodWinEventProcAddRef = false;
			try
			{
				winmdroot.Foundation.HMODULE hmodWinEventProcLocal;
				if (hmodWinEventProc is object)
				{
					hmodWinEventProc.DangerousAddRef(ref hmodWinEventProcAddRef);
					hmodWinEventProcLocal = (winmdroot.Foundation.HMODULE)hmodWinEventProc.DangerousGetHandle();
				}
				else
					hmodWinEventProcLocal = (winmdroot.Foundation.HMODULE )new IntPtr(0L);
				winmdroot.UI.Accessibility.HWINEVENTHOOK __result = PInvoke.SetWinEventHook(eventMin, eventMax, hmodWinEventProcLocal, pfnWinEventProc, idProcess, idThread, dwFlags);
				return new UnhookWinEventSafeHandle(__result, ownsHandle: true);
			}
			finally
			{
				if (hmodWinEventProcAddRef)
					hmodWinEventProc.DangerousRelease();
			}
		}

		/// <summary>Sets an event hook function for a range of events.</summary>
		/// <param name="eventMin">
		/// <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b> Specifies the <a href="https://docs.microsoft.com/windows/desktop/WinAuto/event-constants">event constant</a> for the lowest event value in the range of events that are handled by the hook function. This parameter can be set to <b>EVENT_MIN</b> to indicate the lowest possible event value.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwineventhook#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="eventMax">
		/// <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b> Specifies the event constant for the highest event value in the range of events that are handled by the hook function. This parameter can be  set to <a href="https://docs.microsoft.com/windows/desktop/WinAuto/event-constants">EVENT_MAX</a> to indicate the highest possible event value.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwineventhook#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="hmodWinEventProc">
		/// <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HMODULE</a></b> Handle to the DLL that contains the hook function at <i>lpfnWinEventProc</i>, if the WINEVENT_INCONTEXT flag is specified in the <i>dwFlags</i> parameter. If the hook function is not located in a DLL, or if the WINEVENT_OUTOFCONTEXT flag is specified, this parameter is <b>NULL</b>.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwineventhook#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="pfnWinEventProc">
		/// <para>Type: <b>WINEVENTPROC</b> Pointer to the event hook function. For more information about this function, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-wineventproc">WinEventProc</a>.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwineventhook#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="idProcess">
		/// <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">DWORD</a></b> Specifies the ID of the process from which the hook function receives events. Specify zero (0) to receive events from all processes on the current desktop.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwineventhook#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="idThread">
		/// <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">DWORD</a></b> Specifies the ID of the thread from which the hook function receives events. If this parameter is zero, the hook function is associated with all existing threads on the current desktop.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwineventhook#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="dwFlags">
		/// <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
		/// <para>Flag values that specify the location of the hook function and of the events to be skipped. The following flags are valid:</para>
		/// <para></para>
		/// <para>This doc was truncated.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwineventhook#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b>HWINEVENTHOOK</b> If successful, returns an <a href="https://docs.microsoft.com/windows/desktop/WinAuto/hwineventhook">HWINEVENTHOOK</a> value that identifies this event hook instance. Applications save this return value to use it with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-unhookwinevent">UnhookWinEvent</a> function. If unsuccessful, returns zero.</para>
		/// </returns>
		/// <remarks>
		/// <para>This function allows clients to specify which processes and threads they are interested in. If the <i>idProcess</i> parameter is nonzero and <i>idThread</i> is zero, the hook function receives the specified events from all threads in that process. If the <i>idProcess</i> parameter is zero and <i>idThread</i> is nonzero, the hook function receives the specified events only from the thread specified by <i>idThread</i>. If both are zero, the hook function receives the specified events from all threads and processes. Clients can call <b>SetWinEventHook</b> multiple times if they want to register additional hook functions or listen for additional events. The client thread that calls <b>SetWinEventHook</b> must have a message loop in order to receive events. When you use <b>SetWinEventHook</b> to set a callback in managed code, you should use the <a href="https://docs.microsoft.com/dotnet/api/system.runtime.interopservices.gchandle">GCHandle</a> structure to avoid exceptions. This tells the garbage collector not to move the callback. For out-of-context events, the event is delivered on the same thread that called <b>SetWinEventHook</b>. In some situations, even if you request WINEVENT_INCONTEXT events, the events will still be delivered out-of-context. These scenarios include events from console windows and events from processes that have a different bit-depth (64 bit versus 32 bits) than the caller.</para>
		/// <para>While a hook function processes an event, additional events may be triggered, which may cause the hook function to reenter before the processing for the original event is finished. The problem with reentrancy in hook functions is that events are completed out of sequence unless the hook function handles this situation. For more information, see <a href="https://docs.microsoft.com/windows/desktop/WinAuto/guarding-against-reentrancy-in-hook-functions">Guarding Against Reentrancy</a>. <b>Windows Store app development</b> If dwFlags is WINEVENT_INCONTEXT AND (idProcess = 0 | idThread = 0), then window hook DLLs are not loaded in-process for the Windows Store app processes and the Windows Runtime broker process unless they are installed by UIAccess processes (accessibility tools). The notification is delivered on the installer's thread. This behavior is similar to what happens when there is an architecture mismatch between the hook DLL and the target application process, for example, when the hook DLL is 32-bit and the application process 64-bit.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwineventhook#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("USER32.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern winmdroot.UI.Accessibility.HWINEVENTHOOK SetWinEventHook(uint eventMin, uint eventMax, winmdroot.Foundation.HMODULE hmodWinEventProc, winmdroot.UI.Accessibility.WINEVENTPROC pfnWinEventProc, uint idProcess, uint idThread, uint dwFlags);

		/// <summary>Retrieves the name of the class to which the specified window belongs. (GetClassNameW)</summary>
		/// <param name="hWnd">
		/// <para>Type: <b>HWND</b> A handle to the window and, indirectly, the class to which the window belongs.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getclassnamew#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="lpClassName">
		/// <para>Type: <b>LPTSTR</b> The class name string.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getclassnamew#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="nMaxCount">
		/// <para>Type: <b>int</b> The length of the *lpClassName* buffer, in characters. The buffer must be large enough to include the terminating null character; otherwise, the class name string is truncated to `nMaxCount-1` characters.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getclassnamew#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b>int</b> If the function succeeds, the return value is the number of characters copied to the buffer, not including the terminating null character. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
		/// </returns>
		/// <remarks>
		/// <para>> [!NOTE] > The winuser.h header defines GetClassName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getclassnamew#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("USER32.dll", ExactSpelling = true, EntryPoint = "GetClassNameW", SetLastError = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern int GetClassName(winmdroot.Foundation.HWND hWnd, winmdroot.Foundation.PWSTR lpClassName, int nMaxCount);
	}
}
